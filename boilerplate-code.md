
>
> 这篇始作于 May 13, 2017，迁移至此前最后一次有意义的更新在 Jul 7, 2017
>
> 仅以此文记录在 nationsky 近两年的时光，五味杂陈...
>


# 套路化代码和语法糖

## 引子

想起这对冤家来，是因为刚好最近 team 里有同学挖出个东西来鞭尸：

故事大概是这样的，我们这个 team 维护了一套用 java 撰写的业务托管系统，里面有所谓的多租户的概念，每个租户各有一个自己的 schema 来存储自己的数据，但是服务程序代码跑起来的实例是一套（或者，即便集群化了多个实例也是无差别的，和特定租户无关的），这个形态访问数据库时候怎么办呢？有位先烈（此人应该貌似已经离开这个 team 另谋高就了）就只好自己搞了一套JDBC DataSource接口的实现，对这个架构方式和 DS 的实现手法暂且不做评价，总之里面还用了下 jedis 2.1.0 （可见这东西写的也有年头了，一直没发现还说明了两个问题：测试覆盖不够；实际用户太少），结果呢，出问题了，租户A的数据串到了租户B，且还没什么规律性，还好这个系统不涉及什么资金账号的问题，否则真得是吃不了兜着走了

这个问题是怎么造成的呢？我们知道Jedis的实例本身不是线程安全的，想要线程安全需要用Jedis Pool，但是 jedis 2.1.0 的 pool 使用时候，需要有一个套路化的写法用来把它所谓的 broken 的 Jedis 实例归还到 pool 里，否则的话，JedisPool 也保护不了脆弱的 Jedis 实例，如果访问redis时候发生个什么 timeout 或者其他什么事情的时候，就基本上死翘翘了，这个套路的逻辑就是，当Jedis实例操作redis过程中一旦产生了异常，要明确的告知pool它已经被损坏，其实，严格的说起来这并非是jedis 210的套路，而是Apache common pool的套路

较新版的jedis，把这堆套路化代码封装到了close方法里，这明显有一方面是为了适应JDK 7 try...resource的风格而做出的改进，总之套路化代码被封装了，只需要记得这里有个资源是用完要正确释放（try就够了），具体如何释放（套路）已经不用去考虑了

就team遇到的问题本身来说，Manager 和 Director 们自然侧重点是尽快落实个“最不坏”的方案迅速修复，但是作为不明真相的围观群众，在吃完西瓜之后，难免饱暖思淫欲，老司机就是喜欢等着看彩蛋，觉得真正对于coder来说，真正能在它那卑微绳命里沉淀下来的，还是如何理解和运用和套路相关的概念、知识、手段、还有工具

例如，team 里就如何修改关联问题代码的讨论过程中出现过这么些的声音，从每一类当中，我们都可以看到很多东西：

> 如果用了spring data 的 redis template，就不会出现这个（类）问题了

这确实是 MD 会倾向的一个意见，而且确实在那一刻显得很有力量，毕竟刚好使用 Jedis 210 这一版的redis template在这个问题上，是很好的按套路原理撰写的（其实一直沿用到最新版，在spring data或者干脆叫template这个家族的实现中，jdk7的try...with...resource的地位不是那么明显是和spring在这里要解决——某种意义上已经可以说叫做制造——的问题有关），确实，安全快速的出活儿，才是老板付你薪水的原因；

使用 spring 这种框架（粘合剂式的）当然没错，这是生产力，否则就好像有大显示器你还偏要看小屏一样，但如果出发点是依赖这类框架去规避一些问题，而不是认清这些问题的基础上选择合适的工具，那是会对长远造成伤害的，主要的表现是知识的陈旧和认知层面上的狭隘，这个问题后面再展开讨论，这里列举两个值得注意的现象：

* 使用spring redistemplate时候又一层封装抽象
* 对redis本身接口能力认知的不足

> 直接 jedis 273 往上，使用try.with.resource风格

从我个人来说，这是我目前撰写新代码的首选，理想化的角度看这是最简洁干净的选择，不过，还好大家其实都蛮保守的，这个节骨眼上（临近发版），大量的修改代码很难说它是那个最不坏的选择

> 用自己的一个封装，来屏蔽273和210的区别，封装套路化的代码

这个相对来说可能最不可取，一方面，几乎是再造一个spring data RedisTemplate里面的RedisConnectionUtils（从它的发展轨迹上看，就是这样一个事实），而这个封装对于新版jedis来说完全就是多余的了，再者，从工程上看，也是要大面积的修改代码，因此这可能是下下之选

> 迅速search所有代码，把没有按套路撰写的地方（或类似RedisTemplate这种封装的）都按套路进行补全，fix 已经release的和即将 release的这几个版本，在下一个版本中，再想怎么做

这个选择应该就是最不坏的做法，这是我们最终的解决方案，所以说我们这个 team 做工程还是靠谱的，但离卓越还差那么股精气神

从这个过程当中，我们能看到什么？不同的人关注点不一样，看重的东西自然不一样：工程的、技巧的，特别是面对各类新颖的招式和策略，应该怎么融汇贯通为我所用呢？扯到这个不得不说，[这个电影](http://www.imdb.com/title/tt5074352/)还是蛮好看的


至于套路化的代码或者样本化代码（boilerplate），往大了说是一种pattern，但糟糕的地方在于也是一个anti-pattern，说他是个pattern是因为它确实是很直接有效的针对特定问题的解决方案，说他是anti的，大量的重复结构，语法冗赘，对于维护（阅读）来说就是巨大的干扰项

## 套路化代码的精简套路

我还想在这里引出的东西其实还是各类套路化代码的具体解决方案的一个总结，不一定全面，但是就着这个概念，确实是个整理知识结构的好机会

### Java SE

java在Sun手里的最后几年，确实垂垂老矣，以至于众多拥趸都春心难耐，不是转头别的阵营，也是想着脚踩两只船（鄙人堪数后者），但是7和8的巨大改进还是让java人心里觉得，其实原配的新装和小三的那真是一样的美丽，旧服中也有太多亮色没有发掘，注意经常换姿势，一样的新鲜感

进到这个地界儿的，很大程度上都可以看作语法糖，但是也会有颠覆性的东西，例如注解、lambda表达式，不能说他完全不是为了甜，但是它带来很多更多的东西和可能性

#### 钻石表达式

这是JDK7中新引入的，可以极大的减少键盘敲击次数，其实类型推导，难道这不该早一点做到吗？guava在这个问题上的努力大多可以退休了

不过这类问题，竟然还有另一种坚决办法，那就是视而不见，intellij这个IDE就是这么解决的，我第一次看见时候我只感觉这和很多人脑处理规则十分相同，比如我就对穿插在各类电视剧播放过程中的电视购物具备超强免疫力，只是我实在不太确定我是不是也浪费了我宝贵的视力

#### 针对容器的工厂方法

喜欢语法类奇技淫巧的大多知道{{}}这个玩意儿，多用于快速声明List、Set和Map，十分方便，而且说实话撰写上其实挺漂亮的，但是由于事实又是继承又是内部类的，还是有很多琐碎的问题

* 匿名内部类不能用钻石表达式，哩哩啰啰又是一大堆，要不就是编译器警告，或者禁用编译器警告的注解
* 真正需要字面量声明List和Map的大多期望的是一个Immutable的，这也是guava的另一个设计起点
* 内部类实际上会隐式的引用外部对象，这导致外部对象在满足了垃圾回收条件的时候，能不能标记为可清除还得看他吐出来的一个值对象的脸色

其实，这个匿名内部类静态块儿的蹩脚语法List方面确实早有替代，那就是Arrays.asList，JDK9将会进一步缩减成List.of

Map方面如果等不到7月份（JDK9感觉还得延期），又不想import一个guava库，那...不如趁机练习一下JDK8的stream吧

```java
Map<String, Optional<String>> target = Stream.of(
    new SimpleEntry<>("k1", Optional.of("v1")), 
    new SimpleEntry<>("k2", Optional.of("v2")))
  .collect(Collectors.toMap(Entry::getKey, Entry::getValue));
```

好吧，我承认其实这个确实不怎么样，因为可以发现这本身几乎就是套路化的代码，但是也许值得为此简单的做一个封装，就像长期停留在JDK5、6的时候，不用guava但是又想表示拜服于[Joshua教诲](https://www.amazon.com/Effective-Java-2nd-Joshua-Bloch/dp/0321356683/)

#### Java 面试基础第一题

如果去面试Java的Dev没遇上这个题，那这个team不是太牛B了就是太不靠谱了，再或者就是双方完全在互相忽悠根本不值彼此在干什么，当然如果掌握了正确的姿势之后，也许这些问题一下子是会觉得奇怪，就好像我儿子他们这一代生来就有互联网，而我爷爷他们那一辈看见电灯都会觉得很神奇

好了，这里提到的正主是JDK 7 里面有叫做Compact equal和hashcode的概念，即便是用eclipse生成这两个方法的，建议也要了解这个东西，当然了，一定要能准确理解为什么要正确实现这两个方法，另外还有Comparable接口有时也和这个有关系

有心的一定觉得这不就是短了点么，增加减少field时候该忘还是忘，没错，那就是得直接跳到后面的lombok和AutoValue这两个必杀了

#### _lambda表达式_

刚才那是字面量map的玩儿法确实像是个玩笑，但是stream确实是减少了大票大票的for if for这种深层嵌套，并进行声明式的表达代码意图的利器，同时捎带上optional和方法引用，玩儿起来确实让老Java人不亦乐乎

##### _Optional_

#### JSR 310

Calendar那糟糕的API设计让很多人的自制轮子库中有着或大或小的DateUtils之类的东西存在，可变对象设计简直让SimpleDateFormat成了ThreadLocal的标准教程，到了今天，这一切都省心多了

+ 曾经幻想过无数次的不可变Date，最终敌不过一个莫名其妙的long，现在叫做```Instant.now()```而且人家还精确到了nano，当然多占一些地方也是无法回避的，但是真正令人宽心的还是各种plus和minus方法都不会影响这些实例，LocalDateTime、ZoneDateTime还是LocalDate或ZoneDate清晰无误的表达了哪天还是哪刻的问题，表达个某天开始结束也都不在话下

### 框架、库

#### lombok

初见lombok，是因为手写Builder写吐了，尝试了一堆什么eclipse插件或者代码模板的写法都感觉胃部不适，直到把lombok拿到手里

它所有的特点，官方描述文档都描述的很好了，或者google一下groups之类深度解析的，都很清楚了，说什么觉得也是画蛇添足，只在这里对@SneakyThrows这个注解表达一下崇敬之情，我确实自己努力为那些根本不可能抛出的受检异常浪费了不少的人生，但在这东西面前，我彻底拜服了，不能不承认自己学艺不精

#### AutoValue


_**... to be continue ...**_